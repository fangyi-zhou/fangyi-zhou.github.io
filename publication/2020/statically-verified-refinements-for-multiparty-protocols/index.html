<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Statically Verified Refinements for Multiparty Protocols - Fangyi Zhou</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="With distributed computing becoming ubiquitous in the modern era, safe
distributed programming is an open challenge. To address this, multiparty
session types (MPST) provide a typing discipline for message-passing
concurrency, guaranteeing communication safety properties such as deadlock
freedom.
While originally MPST focus on the communication aspects, and employ a simple
typing system for communication payloads, communication protocols in the real
world usually contain constraints on the payload. We introduce refined
multiparty session types (RMPST), an extension of MPST, that express data
dependent protocols via refinement types on the data types."><meta property="og:image" content="https://fangyi.io/"><meta property="og:url" content="https://fangyi.io/publication/2020/statically-verified-refinements-for-multiparty-protocols/"><meta property="og:site_name" content="Fangyi Zhou"><meta property="og:title" content="Statically Verified Refinements for Multiparty Protocols"><meta property="og:description" content="With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom.
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain constraints on the payload. We introduce refined multiparty session types (RMPST), an extension of MPST, that express data dependent protocols via refinement types on the data types."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="publication"><meta property="article:published_time" content="2020-11-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Statically Verified Refinements for Multiparty Protocols"><meta name=twitter:description content="With distributed computing becoming ubiquitous in the modern era, safe distributed programming is an open challenge. To address this, multiparty session types (MPST) provide a typing discipline for message-passing concurrency, guaranteeing communication safety properties such as deadlock freedom.
While originally MPST focus on the communication aspects, and employ a simple typing system for communication payloads, communication protocols in the real world usually contain constraints on the payload. We introduce refined multiparty session types (RMPST), an extension of MPST, that express data dependent protocols via refinement types on the data types."><link rel=stylesheet href=https://fangyi.io/css/simple-icons.cc125cfd7958efc8dc27b5dfa6e2a9bbab933ce50b754f77e669e587c16ce857.css type=text/css><link rel=stylesheet href=https://fangyi.io/css/simple-icons.cc125cfd7958efc8dc27b5dfa6e2a9bbab933ce50b754f77e669e587c16ce857.css type=text/css><link rel=stylesheet href=https://fangyi.io/css/simple-icons.cc125cfd7958efc8dc27b5dfa6e2a9bbab933ce50b754f77e669e587c16ce857.css type=text/css><link href=https://fangyi.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://fangyi.io/css/main.a87126a5d38398207e58225b2d1a9faf97f546982f44b3ffb9715a264da36c90.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://fangyi.io/css/dark.f163b79c6de51d14a766ff9f0563053de7f06a4d1bf7b85a59608bf96e566710.css media="(prefers-color-scheme: dark)"><link rel=stylesheet href=https://fangyi.io/katex/katex.min.css><script defer src=https://fangyi.io/katex/katex.min.js></script><script defer src=https://fangyi.io/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><div class=main><a href=https://fangyi.io/>Fangyi Zhou</a></div><nav><a href=/>Home</a>
<a href=/post>Posts</a>
<a href=/publication>Publications</a>
<a href=/talks>Talks</a>
<a href=/about>About</a></nav></header><main><article><div class=title><h1 class=title>Statically Verified Refinements for Multiparty Protocols</h1></div><p>Authors:
<b>Fangyi Zhou</b>,
Francisco Ferreira,
Raymond Hu,
Rumyana Neykova,
Nobuko Yoshida.</p><p>DOI: <a href=https://doi.org/10.1145/3428216>10.1145/3428216</a></p><p>Available on arXiv: <a href=https://arxiv.org/abs/2009.06541>2009.06541</a></p><h3>Abstract:</h3><section><p>With distributed computing becoming ubiquitous in the modern era, safe
distributed programming is an open challenge. To address this, multiparty
session types (MPST) provide a typing discipline for message-passing
concurrency, guaranteeing communication safety properties such as deadlock
freedom.</p><p>While originally MPST focus on the communication aspects, and employ a simple
typing system for communication payloads, communication protocols in the real
world usually contain constraints on the payload. We introduce refined
multiparty session types (RMPST), an extension of MPST, that express data
dependent protocols via refinement types on the data types.</p><p>We provide an implementation of RMPST, in a toolchain called Session*, using
Scribble, a toolchain for multiparty protocols, and targeting F*, a
verification-oriented functional programming language. Users can describe a
protocol in Scribble and implement the endpoints in F* using refinement-typed
APIs generated from the protocol. The F* compiler can then statically verify
the refinements. Moreover, we use a novel approach of callback-styled API
generation, providing static linearity guarantees with the inversion of
control. We evaluate our approach with real world examples and show that it has
little overhead compared to a naive implementation, while guaranteeing safety
properties from the underlying theory.</p></section></article></main><footer><div style=display:flex><a class=soc href=https://github.com/fangyi-zhou rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.threads.com/@fangyi.zhou_ rel=me title=Threads><i class="si si-threads"></i></a><a class=border></a><a class=soc href=https://orcid.org/0000-0002-8973-0821 rel=me title=ORCID><i class="si si-orcid"></i></a><a class=border></a><a class=soc href="https://scholar.google.com/citations?user=PPEUHmwAAAAJ" rel=me title="Google Scholar"><i class="si si-googlescholar"></i></a><a class=border></a></div><div class=footer-info>2026 Fangyi Zhou Â© CC BY 4.0 | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>